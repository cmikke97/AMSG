# Copyright 2021, Crepaldi Michele.
#
# Developed as a thesis project at the TORSEC research group of the Polytechnic of Turin (Italy) under the supervision
# of professor Antonio Lioy and engineer Andrea Atzeni and with the support of engineer Andrea Marcelli.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
# an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
# specific language governing permissions and limitations under the License.

import csv  # implements classes to read and write tabular data in CSV format
import json  # json encoder and decoder
import os  # provides a portable way of using operating system dependent functionality
import sys  # system-specific parameters and functions
import tempfile  # used to create temporary files and directories
import zipfile  # provides tools to create, read, write, append, and list a ZIP file
from time import sleep  # used to suspend execution of the calling thread for the given number of seconds

import pyzipper  # a replacement for Pythonâ€™s zipfile that can read and write AES encrypted zip files
import requests  # simple HTTP library for Python
from logzero import logger  # robust and effective logging for Python


class MalwareBazaarAPI:
    """ Simple Malware Bazaar API class. It implements a few methods to interact with Malware Bazaar Rest API. """

    def __init__(self):
        """ Initialize MalwareBazaarAPI class. """

        # set malware bazaar url
        self._url = 'https://mb-api.abuse.ch/api/v1/'
        # set URL where to find the MalwareBazaar full data dump
        self._fullDataDump_url = 'https://bazaar.abuse.ch/export/csv/full/'
        # set the local full data dump (zipped) file name
        self._fullDataDump_zip_filename = 'full_data_dump.zip'
        # set the local full data dump (un-zipped) file name
        self._fullDataDump_filename = 'full.csv'

        # malware bazaar api errors
        self.api_errors = {
            "hash_retrieve": {
                "http_post_expected": "The API expected a HTTP POST request",
                "hash_not_found": "The queried file (hash) is unknown to MalwareBazaar",
                "illegal_hash": "The provided hash is not a valid SHA256 hash",
                "no_hash_provided": "The provided text is not a hash"
            },
            "tag_retrieve": {
                "http_post_expected": "The API expected a HTTP POST request",
                "tag_not_found": "The queried tag is unknown to MalwareBazaar",
                "illegal_tag": "No valid tag provided",
                "no_tag_provided": "The provided text is not a tag",
                "no_results": "Query yielded no results"
            },
            "signature_retrieve": {
                "http_post_expected": "The API expected a HTTP POST request",
                "signature_not_found": "The queried signature is unknown to MalwareBazaar",
                "illegal_signature	": "The provided text is not a valid signature",
                "no_signature_provided": "The provided text is not a signature",
                "no_results": "Query yielded no results"
            },
            "download": {
                "http_post_expected": "The API expected a HTTP POST request",
                "illegal_sha256_hash": "Illegal SHA256 hash provided",
                "no_sha256_hash": "No SHA256 hash provided",
                "file_not_found": "The file was not found or is unknown to MalwareBazaar"
            }
        }

        # set max MalwareBazaarAPI query limit
        self._max_limit = 1000

    def get_full_data_dump(self,
                           dest_dir,  # directory where to extract and save the Malware Bazaar full data dump
                           family_list):  # list of families to retrieve samples of
        """ Get Malware Bazaar full data dump.

        Args:
            dest_dir: Directory where to extract and save the Malware Bazaar full data dump
            family_list: List of families to retrieve samples of
        Returns:
            Dictionary of available samples for the families of interest.
        """

        # initialize a dictionary containing one empty list for each family of interest
        family_samples_dict = {
            k: [] for k in family_list
        }

        # create temporary directory
        with tempfile.TemporaryDirectory() as tempdir:
            # generate path where to save the (zipped) full data dump
            zip_filename = os.path.join(tempdir, self._fullDataDump_zip_filename)

            # request full (zipped) data dump file from the corresponding URL
            r = requests.get(self._fullDataDump_url, allow_redirects=True)

            # open zipped full data dump destination file
            with open(zip_filename, 'wb') as out_file:
                # write received content to file
                out_file.write(r.content)

            # unzip full data dump in the destination directory
            with zipfile.ZipFile(zip_filename, 'r') as zip_ref:
                zip_ref.extractall(dest_dir)

            # generate local (un-zipped) full data dump file path
            csv_filename = os.path.join(dest_dir, self._fullDataDump_filename)

            # open unzipped full data dump in read mode
            with open(csv_filename, 'r') as full_data_csv:
                # get all lines
                lines = full_data_csv.readlines()
                # skip some lines and remove all '"' characters
                selected_lines = [s.replace('"', '') for s in lines[8:-1]]
                # remove the heading "# " string from the first line
                selected_lines[0] = selected_lines[0].split('# ')[-1]

            # open the file in write mode
            with open(csv_filename, 'w') as full_data_csv:
                # save to file the processed full data dump removing all ' ' characters
                full_data_csv.write(''.join([s.replace(' ', '') for s in selected_lines]))

            # open the csv data dump file in read mode
            with open(csv_filename, 'r') as csv_file:
                # use csv dictReader class to interpret the csv file content as a python object
                reader = csv.DictReader(csv_file)
                # for each row in the csv reader
                for row in reader:
                    # get current sample info
                    curr_first_seen = row['first_seen_utc']
                    curr_sha256 = row['sha256_hash']
                    curr_type = row['file_type_guess'].lower()
                    curr_family = row['signature'].lower()

                    # if the current file is an executable
                    if curr_type == 'exe':
                        # if the family of the current file is one of the families of interest
                        if curr_family in family_list:
                            # save current file sha and first seen time in the family samples dictionary
                            family_samples_dict[curr_family].append({
                                'sha256_hash': curr_sha256,
                                'first_seen_utc': curr_first_seen
                            })

            # for each family in the set of families of interest
            for fam in family_list:
                # sort the samples by their first seen time in reverse order
                family_samples_dict[fam] = sorted(family_samples_dict[fam], key=lambda item: (item['first_seen_utc']),
                                                  reverse=True)

        # return dictionary of available samples
        return family_samples_dict

    @staticmethod
    def check_sha256(s):  # (supposedly) sha256 of a malware sample
        """ Check if the string provided is a valid sha256 hash value.

        Args:
            s: (Supposedly) Sha256 of a malware sample
        Returns:
            's' if it is a valid sha256 hash.
        """

        # if s is empty just return
        if s == "":
            return

        # if the length of s is wrong raise exception
        if len(s) != 64:
            raise ValueError("Please use sha256 value instead of '" + s + "'")

        # return s as string
        return str(s)

    def query(self,
              query,  # hash/tag/signature to retrieve metadata of
              qtype='hash'):  # type of query to make; valid options are "hash", "tag" or "signature"
        """ Get a list of malware samples' info (max 1'000) associated with a specific hash/tag/signature.

        Args:
            query: Hash/Tag/signature to retrieve metadata of
            qtype: Type of query to make; valid options are "hash", "tag" or "signature" (default: 'hash')
        Returns:
            Malware metadata list.
        """

        # if the query type is different from expected log error and exit
        if qtype != 'hash' and qtype != 'tag' and qtype != 'signature':
            logger.error('Unknown query type. Valid options are "hash", "tag" or "signature".')
            sys.exit(1)

        if qtype == 'hash':
            # define data to post to Rest API
            data = {
                'query': 'get_info',  # type of action: retrieve hash metadata
                'hash': self.check_sha256(query),  # retrieve sample's metadata associated with this hash
            }
        elif qtype == 'tag':
            # define data to post to Rest API
            data = {
                'query': 'get_taginfo',  # type of action: retrieve tag metadata
                'tag': str(query),  # retrieve samples' metadata associated with this tag
                'limit': str(self._max_limit),  # get the first 'limit' samples
            }
        else:
            # define data to post to Rest API
            data = {
                'query': 'get_siginfo',  # type of action: retrieve signature metadata
                'signature': str(query),  # retrieve samples' metadata associated with this signature
                'limit': str(self._max_limit),  # get the first 'limit' samples
            }

        response = None

        while True:
            try:
                # send post request to Malware Bazaar Rest API and retrieve response
                response = requests.post(self._url, data=data, timeout=30)
                break
            except requests.Timeout:  # in case of a timeout log error, wait and retry
                logger.error("Connection timeout. Retrying in 30 seconds.")
                sleep(30)
                continue

        try:
            # decode response content and interpret it as json
            json_response = response.json()
        except json.decoder.JSONDecodeError:  # in case of a JSON decode error log error and return
            logger.error("Malware Bazaar response is not a valid JSON document.")
            return None

        # get response query status
        query_status = json_response['query_status']
        # if the current query status matches one of the possible errors log error and return None
        if query_status in self.api_errors[qtype + '_retrieve'].keys():
            logger.error(self.api_errors[qtype + '_retrieve'][query_status])
            return None

        # get malware metadata list from response
        malware_list = json_response['data']

        # return malware metadata list
        return malware_list

    def retrieve_malware_sample(self,
                                sha256_hash,  # sha256 hash of the malware sample to retrieve
                                dest_dir,  # destination directory where to save file
                                unzip=False):  # whether to unzip downloaded file or not
        """ Download malware sample from Malware Bazaar given its sha256 hash.

        Args:
            sha256_hash: Sha256 hash of the malware sample to retrieve
            dest_dir: Destination directory where to save file
            unzip: Whether to unzip downloaded file or not (default: False)
        Returns:
            Name list or filename.
        """

        # set zip password
        ZIP_PASSWORD = b'infected'
        # set post header
        headers = {'API-KEY': ''}

        # define data to post to Rest API
        data = {
            'query': 'get_file',  # type of action: retrieve malware sample
            'sha256_hash': self.check_sha256(sha256_hash),  # sha256 of the sample to retrieve
        }

        response = None

        while True:
            try:
                # send post request to Malware Bazaar Rest API and retrieve response
                response = requests.post(self._url, data=data, headers=headers, timeout=30, allow_redirects=True)
                break
            except requests.Timeout:  # in case of a timeout log error, wait a while and retry
                logger.error("Connection timeout. Retrying in 30 seconds.")
                sleep(30)
                continue
            except requests.ConnectionError:  # in case of a connection error log it, wait a while and retry
                logger.error("A network problem occurred. Retrying in 30 seconds.")
                sleep(30)
                continue

        # if Malware Bazaar did not find the file log error and exit
        if 'file_not_found' in response.text:
            logger.error("Error: file not found")
            return None

        # define destination filename as a concatenation of the dest dir with the sha256 hash of the file
        filename = os.path.join(dest_dir, sha256_hash + '.zip')
        # open destination file in binary write mode and write the response content to it
        open(filename, 'wb').write(response.content)

        # if the user selected the unzip option
        if unzip:
            try:
                # open zip file through AESZipFile object of package pyzipper
                with pyzipper.AESZipFile(filename) as zf:
                    # set zip file password
                    zf.pwd = ZIP_PASSWORD
                    # extract all members from the archive to the current working directory
                    _ = zf.extractall(dest_dir)
                    # return list of archive members by name
                    namelist = zf.namelist()
            except pyzipper.zipfile.BadZipFile:
                # remove file and return none
                os.remove(filename)
                logger.error('Downloaded file {} is not a zip file.'.format(filename))
                return None

            # remove zipped version
            os.remove(filename)
            # return name list
            return namelist
        else:
            # return filename
            return [sha256_hash + '.zip']
